/**
 * FILE: src/lib/init/utils-helpers.ts
 * PURPOSE: Helper functions for init pipeline
 * OWNERSHIP: CLI
 */

import { join, resolve } from 'path';
import { CliError, ExitCode } from '../errors';
import { pathExists, writeTextFile } from '../fs';
import { execCommand } from '../exec';
import { createStepRunner } from '../step-runner';
import { CLI_AUDIT_DIR } from '../constants';
import { getCliVersion } from '../version';
import { createManifest } from '../manifest';
import { verifyInitResult, verifyCoreBaselineAcceptance, verifyGeneratedProjectStructure } from '../init-verification';
import { verifyDxBaselineAcceptance } from '../dx-verification';
import { generateCoreContracts } from '../core-contracts';
import { generateRuntimeComposition } from '../runtime-composition';
import { configureImportAliases, configureSvgPipeline, configureFontsPipeline, configureEnvPipeline, configureBaseScripts } from '../dx-config';
import { generateCiCdWorkflows } from '../cicd-workflows';
import type { InitInputs } from './types';
import type { RuntimeContext } from '../runtime';

/**
 * Generates icons.ts file by running gen:icons script (if SVG is enabled)
 */
export function generateIconsTs(
  appRoot: string,
  inputs: InitInputs,
  stepRunner: ReturnType<typeof createStepRunner>
): void {
  stepRunner.start('Generate icons.ts');
  
  try {
    // Run the gen:icons script that was added by configureBaseScripts
    const command = `${inputs.packageManager} run gen:icons`;
    execCommand(command, {
      cwd: appRoot,
      stdio: 'pipe', // Suppress output unless verbose
    });
    stepRunner.ok('Generate icons.ts');
  } catch (error) {
    // If gen:icons fails (e.g., no SVG files yet), log warning but don't fail init
    stepRunner.ok('Generate icons.ts (skipped - no SVG files found or script failed)');
    // User can run it manually later when they add SVG files
  }
}

/**
 * Applies CORE DX configs (section 04)
 * 
 * BLUEPRINT REFERENCE RULE (section 2.4):
 * - Reference docs/ReactNativeCLITemplate/ for config patterns (babel.config.js,
 *   tsconfig.json, metro.config.js, etc.)
 * - Apply patterns to generated app's config files, but don't copy blueprint files directly
 */
export function applyCoreDxConfigs(
  appRoot: string,
  inputs: InitInputs,
  stepRunner: ReturnType<typeof createStepRunner>
): void {
  stepRunner.start('Apply CORE DX configs');
  
  // 4.1: Configure import aliases (@rns/* and optional @/*)
  if (inputs.coreToggles.alias) {
    configureImportAliases(appRoot, inputs);
  }
  
  // 4.2: Configure SVG import pipeline
  if (inputs.coreToggles.svg) {
    configureSvgPipeline(appRoot, inputs);
  }
  
  // 4.3: Configure fonts pipeline
  if (inputs.coreToggles.fonts) {
    configureFontsPipeline(appRoot, inputs);
  }
  
  // 4.4: Configure env pipeline
  if (inputs.coreToggles.env) {
    configureEnvPipeline(appRoot, inputs);
  }
  
  // 4.5: Configure base scripts (developer workflow)
  configureBaseScripts(appRoot, inputs);
  
  // 4.6: Generate icons.ts if SVG is enabled (after scripts are configured)
  if (inputs.coreToggles.svg) {
    generateIconsTs(appRoot, inputs, stepRunner);
  }
  
  stepRunner.ok('Apply CORE DX configs');
}

/**
 * Writes CORE baseline audit marker (section 3.6)
 */
export function writeCoreBaselineMarker(
  appRoot: string,
  inputs: InitInputs
): void {
  const timestamp = new Date().toISOString();
  const cliVersion = getCliVersion();
  
  const markerContent = `CORE Baseline Installed
========================

CLI Version: ${cliVersion}
Init Timestamp: ${timestamp}
Workspace Model: Option A

This marker indicates that the CORE baseline has been successfully installed.
CORE packages are located in packages/@rns/* and provide plugin-free contracts
with safe defaults.

Generated by: CliMobile init command
`;

  const markerPath = join(appRoot, CLI_AUDIT_DIR, 'BASE_INSTALLED.txt');
  writeTextFile(markerPath, markerContent);
}

/**
 * Writes .rn-init.json state file
 * Now uses the manifest system for proper schema validation
 */
export function writeProjectStateFile(
  appRoot: string,
  inputs: InitInputs
): void {
  // Use manifest system instead of direct JSON write
  createManifest(appRoot, inputs);
}

/**
 * Validates init result (section 2.5 acceptance criteria)
 */
export function validateInitResult(
  appRoot: string,
  context: RuntimeContext,
  stepRunner: ReturnType<typeof createStepRunner>
): void {
  stepRunner.start('Validate init result');
  
  const verification = verifyInitResult(appRoot);
  
  if (!verification.success) {
    const errorMessage = `Init validation failed:\n${verification.errors.map(e => `  - ${e}`).join('\n')}`;
    if (verification.warnings.length > 0) {
      context.logger.info(`Warnings: ${verification.warnings.join(', ')}`);
    }
    throw new CliError(errorMessage, ExitCode.VALIDATION_STATE_FAILURE);
  }
  
  if (verification.warnings.length > 0) {
    context.logger.info(`Validation warnings: ${verification.warnings.join(', ')}`);
  }
  
  stepRunner.ok('Validate init result');
}

/**
 * Verifies metro.config.js loads without errors
 */
export function verifyMetroConfigLoads(
  appRoot: string,
  target: 'expo' | 'bare'
): void {
  const metroConfigPath = join(appRoot, 'metro.config.js');
  
  if (!pathExists(metroConfigPath)) {
    // Metro config may not exist for Bare RN (uses default)
    // But if we created one (e.g., for SVG), it must load
    return;
  }
  
  try {
    // Try to require the metro config to verify it loads
    // This will fail if dependencies are missing (e.g., react-native-svg-transformer)
    // Use absolute path and escape it properly for shell
    const absolutePath = resolve(metroConfigPath);
    const escapedPath = absolutePath.replace(/\\/g, '/').replace(/'/g, "\\'");
    execCommand(`node -e "require('${escapedPath}')"`, {
      cwd: appRoot,
      stdio: 'pipe',
    });
  } catch (error: any) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new CliError(
      `metro.config.js failed to load:\n${errorMessage}\n` +
      `This usually means a required dependency is missing.\n` +
      `Check that all dependencies referenced in metro.config.js are installed.\n` +
      `For SVG support, ensure react-native-svg and react-native-svg-transformer are installed.`,
      ExitCode.VALIDATION_STATE_FAILURE
    );
  }
}

/**
 * Runs boot sanity checks
 */
export function runBootSanityChecks(
  appRoot: string,
  inputs: InitInputs,
  stepRunner: ReturnType<typeof createStepRunner>
): void {
  stepRunner.start('Run boot sanity checks');
  
  // Check required files present
  const requiredFiles = ['package.json'];
  if (inputs.target === 'expo') {
    requiredFiles.push('app.json');
  }
  
  for (const file of requiredFiles) {
    if (!pathExists(join(appRoot, file))) {
      throw new CliError(`Required file not found: ${file}`, ExitCode.VALIDATION_STATE_FAILURE);
    }
  }
  
  // TODO: Check workspace packages are resolvable (requires dependency install)
  
  stepRunner.ok('Run boot sanity checks');
}

/**
 * Applies plugins if selected (stub - will be completed in section 13)
 */
export async function applyPlugins(
  appRoot: string,
  plugins: string[],
  inputs: InitInputs,
  context: RuntimeContext,
  stepRunner: ReturnType<typeof createStepRunner>
): Promise<void> {
  if (plugins.length === 0) {
    return;
  }
  
  stepRunner.start('Apply plugins');
  
  // TODO: Apply plugins using standard plugin apply pipeline (section 13)
  
  stepRunner.ok('Apply plugins');
}

/**
 * Prints next steps for the user
 */
export function printNextSteps(
  appRoot: string,
  inputs: InitInputs
): void {
  const cdCommand = `cd ${appRoot}`;
  const startCommand = inputs.target === 'expo' 
    ? `${inputs.packageManager} run start`
    : `${inputs.packageManager} run android`; // or ios
  
  console.log('\nâœ“ Project initialized successfully!\n');
  console.log('Next steps:');
  console.log(`  1. ${cdCommand}`);
  console.log(`  2. ${startCommand}`);
  console.log('\n');
}
